package dev.rushii.rgp

import org.gradle.api.Named
import org.gradle.api.Project
import org.gradle.api.provider.*
import javax.inject.Inject

/**
 * Configures a specific Cargo project to be built.
 */
public abstract class CargoProjectDeclaration @Inject internal constructor(name: String, project: Project) : Named {
	/**
	 * The name of this declaration.
	 *
	 * This is used when generating gradle tasks.
	 */
	public val name: Property<String> = project.objects
		.property(String::class.java)
		.value(name)
		.apply { finalizeValue() }

	/**
	 * The name of the output binary generated by Cargo excluding any platform-specific prefixes.
	 * This should match the `lib.name` property in `Cargo.toml`, for example:
	 *
	 * ```toml
	 * [lib]
	 * name = "hello"
	 * crate-type = ["cdylib"]
	 * ```
	 * The `libName` should therefore be set to `hello`.
	 * This would then generate `libhello.so` for Linux, `libhello.dylib` for macOS/iOS, and `hello.dll` for Windows.
	 *
	 * By default, this is empty. If so, then [extraIncludes] must be set instead
	 * to determine what file(s) to copy as part of the task outputs.
	 */
	public val libName: Property<String> = project.objects.property(String::class.java)

	/**
	 * The names/globs of extra files to include when copying from the Cargo target build directory.
	 * This is relative to `<projectPath>/target/<target>/<profile>/`.
	 *
	 * This might be useful if copying debug symbols to task outputs is necessary.
	 *
	 * By default, this is empty. If [libName] is not set, then this property becomes required.
	 */
	public val extraIncludes: ListProperty<String> = project.objects.listProperty(String::class.java)

	/**
	 * The name or path of the Cargo executable to use when building.
	 *
	 * This can be changed for an absolute path to a specific version of `cargo`, or for another cargo-compatible tool
	 * like `cross`.
	 *
	 * By default, this is `cargo`, using the executable on the `PATH`.
	 */
	public val cargoExecutable: Property<String> = project.objects
		.property(String::class.java)
		.convention("cargo")

	/**
	 * The path to the directory where a Cargo project exists
	 */
	public val projectPath: Property<String> = project.objects.property(String::class.java)

	/**
	 * Name of the profile to pass to Cargo through `--profile=...`.
	 *
	 * By default, this is `debug`.
	 */
	public val profile: Property<String> = project.objects
		.property(String::class.java)
		.convention("debug")

	/**
	 * Optional extra arguments to pass to Cargo when running a build for a target.
	 *
	 * This does not replace any Cargo arguments added by this plugin.
	 */
	public val cargoArguments: ListProperty<String> = project.objects.listProperty(String::class.java)

	/**
	 * Optional extra environment variables to pass to Cargo when running a build for a target.
	 *
	 * Any conflicting entries will overwrite the environment variables set by this plugin.
	 */
	public val cargoEnvironmentVariables: MapProperty<String, Any> = project.objects.mapProperty(String::class.java, Any::class.java)

	/**
	 * A list of targets that will each be built by Cargo.
	 *
	 * Each target must be a valid target triple as defined by Cargo [here](https://doc.rust-lang.org/nightly/rustc/platform-support.html).
	 */
	public val targets: SetProperty<String> = project.objects.setProperty(String::class.java)

	/**
	 * The configuration for the Android NDK to be used for this project.
	 * This is only applicable for Android Cargo targets.
	 */
	public val android: Property<AndroidDeclaration> = project.objects
		.property(AndroidDeclaration::class.java)
		.convention(project.provider(::AndroidDeclaration))

	/**
	 * Declare or configure the Android NDK to be used for this project.
	 * This is only applicable for Android Cargo targets.
	 */
	public fun projects(block: AndroidDeclaration.() -> Unit) {
		block(android.get())
	}

	override fun getName(): String = name.get()
}
